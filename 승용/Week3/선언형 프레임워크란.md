### SwiftUI의 뷰
- SwiftUI의 뷰는 UI의 일부분을 정의하는 역할을 가진다. 
- SwiftUI는 UIKit과 똑같이 뷰 계층구조(View Hierachy)를 사용해 뷰의 관계를 표현한다.
<img width="274" alt="Screenshot 2024-06-10 at 12 21 18 PM" src="https://github.com/All-About-iOS/Weekly-I-Learned/assets/22342277/b1590826-00fc-4a5e-be21-928d04bd5629">

```swift
VStack {
	Text("Avocado Toast").font(.title)

	Toggle(isOn: $order.includeSalt) {
		Text("Include Salt")
	}
	Toggle() {
		Text()
	}
	Stepper() {
		Text()
	}

	Button() {
		Text()
	}
}
```

### UIKit vs SwiftUI 뷰 계층구조 표현의 차이점
- UIKit 코드는 뷰를 생성을 지시하고, 뷰의 입력과 크기 등을 지정하고, 뷰를 뷰 계층에 추가하라고 지시(addSubview)한다. 
- SwiftUI 코드를 보면 뷰 계층구조 다이어그램과 일치한다. 
    - 지시(명령)을 통해 하나씩 쌓아올리는 대신, SwiftUI는 이미 완전한 형태로 설계된 구조로 뷰 계층구조를 초기화 해버린다. 
- 이것이 명령형(Imperative) 코드와 선언형(Declarative) 코드의 차이

### 명령형 코드와 선언형 코드
- 간단한 토스트 만들기 예시
- 명령형 코드: 전화를 통해 친구에게 원하는 토스트를 만들도록 지시하기
    - 빵을 꺼내서
    - 버터를 바르고
    - 빵을 굽고
    - 딸기잼을 꺼내서
    - ...
    - 각각의 단계를 지시, 만드는 방법에 대한 세부적인 명령 필요
- 선언형 코드: 토스트 가게에서 원하는 토스트 주문하기
    - 딸기잼을 바른 토스트 주세요
    - 원하는 결과만 묘사, 어떻게 그것을 만드는지는 전문가(SwiftUI)에게 맡기기

- 명령형 코드는 각 단계가 정확한 순서와 지시로 이루어지지 않으면 원하는 결과를 얻을 수 없다. 
- ex) 빵을 구운 후 버터를 바른 것과 버터를 바르고 빵을 구운 것을 다른 결과임.
- 선언형 코드는 원하는 것을 정확하게 표현하기만 하면, 전문가가 알아서 만들어준다.


### SwiftUI에서 선언형으로 코드를 구현하는 방식
- SwiftUI는 View 프로토콜을 따르는 구조체를 통해 UI를 선언적으로 정의한다. 
- 해당 구조체는 어떤 뷰가 어떤 자식 뷰를 포함하는지를 계층 구조로 정의한다.
- SwiftUI는 이러한 정의를 바탕으로 실제 UI를 렌더링한다. 
    - 계층구조로 선언된 구조체를 렌더링하는 어려운 작업은 프레임워크가 담당!
```swift
public protocol View {
    associatedtype Body: View

    var body: Body { get }
}
```
- View 프로토콜의 각 구체 타입들은 body 프로퍼티에서 content를 나타내는 다른 뷰를 캡슐화하고, 그 뷰를 생성하기 위한 입력값을 자기 자신의 프로퍼티로 나타낸다. 
- 이러한 구조는 재귀적으로, 뷰의 body 내부의 뷰의 body 내부에 뷰... 가 위치하게 된다.
```swift
// 요런 방식으로
VStack {
    Button() {
        Text("button")
    }
}
```
- 언젠가는 가장 아랫단계가 있어야 하는데, 그것이 바로 SwiftUI가 제공하는 기본 뷰(primitive View)이며 가장 원자적인 구성 요소이다. 
    - ex) Text 등
- 프로토콜 + 구조체로 구현된 뷰는 클래스 + 상속으로 구현된 뷰에 비해 어떤 장점이 있을까? 
- UIKit에서는 슈퍼클래스로부터 상속받아 사용한 기본 프로퍼티(color, opacity 등)들을 SwiftUI에서는 modifier로 분리할 수 있게 되었다.
- 따라서 뷰 자체는 가볍고 더 고유한 목적을 가질 수 있게 되었고, 기본적인 요소는 작고 간단하지만 그것들을 조합하면 어떤 어려운 뷰도 만들 수 있는 가능성을 가지게 되었다. 
- 또한 이러한 구조는 뷰를 입력값에 대한 함수와도 같이 선언적으로 정의하게 만든다. 
- 지속적으로 존재하며 시간이 지남에 따라 명령적 이벤트 기반 코드로 업데이트되는 UIView 객체와는 달리, 입력값이 바뀔 때 마다 body 계산 프로퍼티를 다시 호출해 새로운 뷰를 생성한다.
    - ex) List는 현재 데이터에 변경사항이 생기면 자동으로 달라진 부분만을 계산해서 반영
    - 테이블뷰, 컬렉션뷰 처럼 데이터소스를 변경하고 적용하거나 스냅샷을 생성하고 적용하는 과정이 없음

### 선언형 코드의 장점
- 위와 같이 구현된 SwiftUI의 선언형 코드는 아래와 같은 장점을 가진다:
    - 코드 간결성이 높다.
        - UI의 상태와 레이아웃이 직관적으로 드러난다. 
    - 유지보수가 쉽다.
        - 무엇이 UI 변경 및 버그에 영향을 미치는지 파악하기 쉽다.
    - 개발 속도가 빠르다.
        - 더 적은 코드로 더 많은 기능을 구현 가능하다.

### 선언형 코드의 단점
- 세부적인 제어가 어렴다:
    - 개발자가 세부적으로 "어떻게 할 것인가"를 제어하기 어려울 수 있다.
    - 그 부분은 프레임워크에 맡기기 때문
    
