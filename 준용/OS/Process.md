# 프로세스 ( Process )

## 정의

- 실행 중인 프로그램.
    - 보조 기억장치에 저장된 프로그램을 메모리에 적재하고, 실행하면 프로세스가 된다.
    - 이러한 과정을 `프로세스를 생성한다` 라고 한다.
        - 이 말은 즉, 저장장치에 저장되어 있지만 메모리에는 적재되지 않은 상태를 **프로그램**이라고 한다는 것.
            <img src="https://github.com/JUNY0110/Weekly-I-Learned/assets/98405970/10ba9df7-4448-4aab-a2a0-f9974d56a311" width=300>
- 프로세스는 **포그라운드 프로세스(Foreground process), 백그라운드 프로세스(Background process)** 로 나뉘며
    - 포그라운드 프로세스는 사용자가 보는 앞에서 실행되는 프로세스이며
    - 백그라운드 프로세스는 사용자가 보지 못하는 곳에서 실행되는 프로세스이다.
        - 또, 백그라운드 프로세스는 사용자와 상호작용 유무를 기준으로 구분된다.
        - 이러한 백그라운드 프로세스를 유닉스에서는 `데몬` 이라 부른다. (윈도우에서는 `서비스` 라 부름)

---

## 프로세스 제어블록 ( PCB, Process Control Block )

- 프로세스는 실행을 위해 CPU를 필요로 하지만, CPU의 자원은 한정되어 있기 때문에 여러가지 스케줄링 방식을 사용하는데, 이 때 각각의 프로세스가 무엇인지 식별하는 도구가 필요하다. 이 도구가 **프로세스 제어블록**이다.
    - CPU가 일정 시간(주기)마다 차례가 끝났음을 알리며, 이를 **타이머 인터럽트** 라고 한다.
    <img src="https://github.com/JUNY0110/Weekly-I-Learned/assets/98405970/47bd5cec-669b-421c-83a5-f2506b32b964" width=600>
    
- PCB는 `프로세스와 관련된 정보를 저장하는 자료 구조`로, PCB를 이용해 프로세스를 식별하고 해당 프로세스를 처리하는 데 필요한 정보를 판단한다.
- PCB는 프로세스 생성 시 커널영역에서 만들어지고, 실행이 끝나면 폐기된다.
    - 즉, 새로운 프로세스가 생성되었다 = OS가 PCB를 생성했다. 와 동의어.
    - 프로세스가 종료되었다 = OS가 해당 PCB를 폐기했다. 와 동의어이다.
- PCB에 담기는 정보는 **PID**, **레지스터 값**, **프로세스 상태**, **CPU 스케줄링 정보**, **메모리 관리 정보**, **사용한 파일과 입출력장치 목록** 등이 있다. 그리고 이러한 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보를 `문맥(Context)` 라고 한다.
    
    ```
    1. 프로세스 ID ( PID )
        - 특정 프로세스를 식별하기 위해 부여하는 고유 번호
    2. 레지스터 값
        - 레지스터: CPU가 요청을 처리하는 데 필요한 데이터를 일시적으로 저장하는 장치
        - 이유: 프로세스는 자신의 실행차례가 돌아오면 이전까지 사용했던 레지스터의 중간값들을 모두 복원하고 진행했던 작업을 이어서 실행할 수 있다.
        - 그래서 PCB에는 프로그램 카운터(PC)를 포함한 레지스터 값이 담겨있다.
    3. 프로세스 상태
        - 프로세스가 무엇을 기다리고, 진행 중인 상태인지 등 프로세스 상태 정보를 PCB에 저장된다.
        ex) 입출력장치 사용 기다리기, CPU 사용 기다리기, CPU 이용 중 등
    4. CPU 스케줄링 정보
    5. 메모리 관리 정보
        - 프로세스마다 메모리에 저장된 위치가 다르기 때문에, PCB에는 어느 주소에 저장되어 있는지 저장하고 있다.
        - 베이스 레지스터, 한계 레지스터 값, 페이지 테이블 정보가 PCB에 담겨있음.
    6. 사용한 파일과 입출력장치 목록
        - 어떤 입출력 장치가 프로세스에 할당되었고, 어떤 파일들을 열었는지에 대한 정보가 PCB에 기록된다.
    ```
    <img src="https://github.com/JUNY0110/Weekly-I-Learned/assets/98405970/c211b26e-bf28-497f-90eb-69a6abfba4d4" width=600>

- 기존 프로세스의 문맥을 PCB에 백업하고, 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하여, **프로세스 간 실행을 전환하는 것을 `문맥 교환(Context Switching)`** 이라고 한다.
    - **여러 프로세스가 빠르게 번갈아가며 실행되는 원리로, 동시에 실행되는 것처럼 보이는 이유**이다.
    - 단, **문맥 교환이 너무 자주 일어나면, 오버헤드가 발생할 수 있기 때문에** 문맥교환이 많이 일어나는 것이 항상 좋다고할 수는 없다.

---

## 프로세스의 메모리 영역

- 커널영역에 PCB가 생성되듯, 사용자 영역의 프로세스에서는 **코드, 데이터, 힙, 스택 영역**으로 나뉘어 저장된다.
    - **코드, 데이터, 힙, 스택 영역 간단 정리**
        
        ### 코드 영역( = 텍스트 영역 )
        
        - 실행할 수 있는 코드. 즉, **기계어로 이루어진 명령어가 저장되는 영역**.
        - CPU가 실행할 명령어가 담겨 있어 쓰기가 금지되어 있으며, **읽기 전용(read-only) 공간**이다.
        
        ### 데이터 영역
        
        - **프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간**으로, 대표적으로 전역변수가 있다.
            - 전역변수: 프로그램이 실행되는 동안 유지되며, 프로그램 전체에서 접근할 수 있는 변수
        
        ### 힙 영역
        
        - **프로그래머가 직접 할당할 수 있는 저장공간**
        - 언젠가는 메모리 공간을 반환해야 하며, 사용하지 않음에도 **반환하지 않으면 메모리 누수(메모리 낭비)를 발생**시킨다.
        
        ### 스택 영역
        
        - **데이터를 일시적으로 저장하는 공간.**
        - 함수가 끝나면 사라지는 매개 변수, 지역 변수가 대표적.
        
- 코드, 데이터는 크기가 변하지 않아 **정적 할당 영역**으로 구분되며, 힙, 스택은 프로세스 실행 과정에서 크기가 변할 수 있기 때문에 **동적 할당 영역**이라고 부른다.
    - 일반적으로 힙 영역은 메모리의 낮은 주소에서 높은 주소로 할당되며, 스택 영역은 메모리의 높은 주소에서 낮은 주소로 할당되어 주소가 겹치는 일이 없도록 설계되어 있다.

      <img src="https://github.com/JUNY0110/Weekly-I-Learned/assets/98405970/bdea6650-485c-4fee-9853-ed8b43ca4a18" width=300>

---

## 프로세스의 상태

- 운영체제는 프로세스의 상태를 PCB에 기록하고, PCB를 통해 인식하고 관리한다.
~~PCB에 프로세스 상태 정보를 기록한다고 위에서 언급.~~
- 프로세스가 가지는 대표적인 상태는 **생성 상태, 준비 상태, 실행 상태, 대기 상태, 종료 상태** 등이 있다.
    
    ### 생성 상태
    
    - 프로세스를 생성 중인 상태.
    - 이제 막 메모리에 적재되어 운영체제로부터 PCB를 할당받은 상태이다.
    
    ### 준비 상태
    
    - CPU를 할당받지 않은 상태로, 언제든 실행될 수 있다.
    - `준비상태 → 실행상태` 로 전환되는 것을 **디스패치** 라고 한다.
    
    ### 실행 상태
    
    - CPU를 할당받아 실행 중인 상태.
    - 프로세스는 CPU를 할당받은 시간만 사용 가능하며, 시간이 모두 소요되면 타이머 인터럽트가 발생하고 다시 준비상태로 돌아간다.
    - 만약 입출력장치를 사용해 입출력장치의 작업 종료를 기다려야 한다면, **대기상태**로 전환된다.
    
    ### 대기 상태
    
    - 특정 이벤트가 일어나길 기다리는 상태.
        - 주로 입출력 장치인 경우가 대부분이며, 입출력 장치는 CPU보다 처리속도가 느리기 때문이다.
    
    ### 종료 상태
    
    - 프로세스가 종료된 상태.
    - 운영체제가 프로세스의 PCB를 제거하고 메모리를 해제한다.

    <img src="https://github.com/JUNY0110/Weekly-I-Learned/assets/98405970/9415bbab-0728-455d-89ce-ad0cda8fe3ef" width=600>


---

## 프로세스 계층 구조

- 프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있는데, 이 때 새 프로세스를 생성한 프로세스를 **부모 프로세스**, 새롭게 생성된 프로세스를 **자식 프로세스** 라고 부른다.
    - 부모 프로세스와 자식 프로세스 프로세스이기 때문에, 독자적인 Proccess ID( = PID )를 갖는다
- 이처럼 프로세스가 프로세스를 낳는 구조를 **프로세스 계층 구조**라고 부른다.

### 프로세스 생성 기법

- 부모 프로세스가 자식 프로세스를 생성하는 방법을 간단하게 짚고 넘어가자.
    1. 부모 프로세스는 **fork()** 를 통해 자신의 복사본을 자식 프로세스로 생성한다.
        - 자식 프로세스는 부모 프로세스의 copy이기 때문에, 부모 프로세스의 자원 대부분을 상속받는다.
            - 다만, 여기서 `CoW(Copy on Write) 개념이 적용`되어, 실제로는 `페이지 테이블(Page table)만 복사`한다.
        - 생성당시에는 부모, 자식 프로세스가 **같은 물리적 메모리 주소를 가리키고 있다**가, 이후 수정사항이 발생하면 새로운 메모리 주소를 할당하게 된다.
            <img src="https://github.com/JUNY0110/Weekly-I-Learned/assets/98405970/49d5c8a7-8e13-4356-88d6-143819a31e1a" width=600>
            
            COW - process1에서 fork()가 호출된 후

            
        - 결과적으로 fork()의 비용은 이정도 뿐이다.
            - 부모 프로세스의 페이지 테이블을 복사하는 비용
            - 자식 프로세스를 기술하기 위한 PCB를 할당받는 비용
    2. 자식 프로세스는 **exec()** 를 통해 자신의 메모리 공간을 다른 프로그램으로 교체한다.(overwrite, 덮어쓰기)
        
        <img src="https://github.com/JUNY0110/Weekly-I-Learned/assets/98405970/37a46938-9e89-45bc-961c-267f603b9027" width=600>
        
        COW - Process1의 특정 페이지에서 수정이 발생한 경우
